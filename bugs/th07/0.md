[title=PCB: Merlin Glitch]  
# Merlin Glitch
  
[hr_major]  
## [specs]  
[hr_minor]

* **Versions**: [unknown]1.00[/unknown] - [unknown]1.00a[/unknown] - [yes]1.00b[/yes]
* **Difficulty**: [yes]Easy[/yes] - [yes]Normal[/yes] - [yes]Hard[/yes] - [yes]Lunatic[/yes] - [no]Extra[/no] - [no]Phantasm[/no]
* **Mode**: [yes]Main game[/yes] - [yes]Practice mode[/yes]
* **Shottype**: [no]ReimuA[/no] - [no]ReimuB[/no] - [no]MarisaA[/no] - [no]MarisaB[/no] - [yes]SakuyaA[/yes] - [yes]SakuyaB[/yes]


## [what]
[hr_minor]

Merlin behaves weirdly during and after the final spell-card.

[img=bugs/th07/0_merlin.png, hratio=2, other= ] [br]

There have been a number of reports in which Merlin bugged out. During this, there are various things Merlin does that do not make much sense.
Once, she kept moving around in circles, even after her final spell-card had happened.
Another time, she still attacked even though the fight has already ended.
Other times, she doesn't despawn after the final spell-card.

Replays are compatible with this bug.
This glitch is extraordinarily rare. [hl2]All current replays/videos[/hl2] related to the glitch that were uploaded before this page was published can be found in the [jumpto=#/bugs/th07/0#links]Links[/jumpto] section of this page.

## [how]
[hr_minor]

The details to do this glitch are quite specific. In particular, [hl2]all the following criteria must be met[/hl2] for the Merlin glitch.

1. Play as Sakuya. This ensures you face Merlin during the first half of the fight.
2. End Merlin's 2nd non-spell during [hl2]a specific time frame[/hl2].
3. End the 1st spell during [hl2]a specific time frame[/hl2]. The time frame is quite large.
4. Target Merlin during the 1st spell.
5. End Merlin's 3rd non-spell during [hl2]a specific time frame[/hl2].
6. End Merlin's solo spell during [hl2]a very specific time frame[/hl2].

What the [hl2]specific time frame[/hl2] is is explained below alongside the probability of success per attack.

### Merlin's subroutines - non-spell 2
[hr_minor]

A subroutine is a set of instructions designed to perform a frequently used operation within a program. Merlin frequently uses subroutines to spawn particle effects and to shoot bullets. In the following sections I denote the subroutines that are involved with the precisely-timed kills. In this section, I denote the subroutines for the 2nd non-spell. Furthermore, the code was decompiled using [a=https://github.com/ExpHP/truth/releases/]truth[/a] v0.5.0.

For non-spell 2, the subroutines are as follows:
[code]void sub80() { // Merlin's 2nd non-spell
    [...]
    loop {
        sub81(1.7671459); // sub81 is the stuff Merlin shoots
+30: // 130
        sub60(30, 0.8); // sub60 makes Merlin move randomly - irrelevant
+30: // 160
        sub81(-1.7671459);
+30: // 190
        sub60(30, 0.8);
+100: // 290
        sub81(-1.7671459);
        sub81(1.7671459);
        sub81(-1.7671459);
+50: // 340
        sub60(30, 1.2);
+50: // 390
    }
}[/code]

[code]void sub81(float FPAR_0) { // what Merlin shoots during non-spell 2
    sub2(4, 32); // particle effects right before she shoots bullets
    [...] // stuff she shoots - lasts for 64 frames
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

So this might be a bit confusing, but I will explain what is going on during the 2nd non-spell.
Firstly, the subroutine ``sub80`` is called. This is Merlin's 2nd non-spell. Now, ``sub80`` can also call for other functions, such as ``sub60`` and ``sub81``. In this case, we want to look at ``sub81``, which is the one responsible for shooting the bullets. ``sub81`` happens to call for ``sub2``, which is responsible for these little particle effects she calls for before attacking. ``sub2`` lasts for exactly 16 frames.
So assuming we start the fight from the 2nd non-spell ``sub80``, Merlin's [hl2]call stack[/hl2] *can* look as follows: ``sub80 → sub81 → sub2``.
I put the word *can* in italics because the call stack can also be different. For example, it can look like this ``sub80 → sub81`` or even this ``sub80``! But note: it cannot be ``sub80 → sub60`` because ``sub60`` is executed instantly.
But wait, how exactly does this work? 
In essence, [hl2]every subroutine lasts for a certain amount of frames[/hl2]. Let's take a look at the code for ``sub80`` again:

[code]void sub80() { // Merlin's 2nd non-spell
    [...]
    loop {
        sub81(1.7671459); // lasts for 8 + 64f
+30: // lasts for 30f
        sub60(30, 0.8); // lasts for 0f
+30: // lasts for 30f
        sub81(-1.7671459);// lasts for 8 + 64f
+30: // lasts for 30f
        sub60(30, 0.8); // lasts for 0f
+100: // lasts for 100f
        sub81(-1.7671459); // lasts for 8 + 64f
        sub81(1.7671459); // lasts for 8 + 64f
        sub81(-1.7671459); // lasts for 8 + 64f
+50: // lasts for 50f
        sub60(30, 1.2); // lasts for 0f
+50: // lasts for 50f
    }
}[/code]
Basically, when the game says ``+50:``, it means that Merlin [hl2]is waiting for 50 frames long[/hl2]. During this time, if we were to end the 2nd non-spell, the call stack would look as follows: ``sub80``.
Secondly, suppose I were to end the 2nd non-spell [hl2]while Merlin is shooting her bullets[/hl2]. She is calling for ``sub81``, but in this case she is not calling for ``sub2``.  Because of this, the call stack would look as follows: ``sub80 → sub81``. 
Thirdly, suppose I were to end the 2nd non-spell [hl2]right before Merlin shoots her bullets[/hl2], so while the particle effects are spawning. She calls for ``sub81``, which calls for ``sub2``. The call stack would look as follows: ``sub80 → sub81 → sub2``. 

Now, [hl2]it's possible to calculate the chance to get the call stack ``sub80 → sub81 → sub2``[/hl2] assuming the probability of the time at which the pattern was killed is [hl2]uniformly distributed[/hl2] (i.e. the chances of killing Merlin during the 386th frame is the same as killing her on the 1024th frame). [hl2]This doesn't reflect real chances[/hl2] due to the fact players would want to speedkill Merlin and this may get consistent kills, but this is the least we could work with.

The entire subroutine ``sub80`` lasts for ``690f`` before it loops. Out of the ``690f``, ``260f`` is spent on waiting. During other ``430f`` she is busy with attacking. Out of the ``430f``, there are ``80f`` where she is busy with calling for ``sub2``. 
So, [hl2]there is a ``80/690`` chance for Merlin to exit the 2nd non-spell[/hl2] with the call stack ``sub80 → sub81 → sub2``. 

### Merlin's subroutines - spell 1
[hr_minor]

Similarly, we can calculate the probabilities for Merlin's other subroutines. The functions used for spell 1 are as follows:

[code]void sub121() { //first spell 
    [...]
    loop {
+40: // lasts for 40f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -4.712389); // lasts for 108f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -6.2831855); // lasts for 108f
        {"HL"}:  wait(40); // lasts for 40f only on Hard/Lunatic mode.
    }
}[/code]

[code]void sub124(float FPAR_0, float FPAR_1) { // stuff Merlin shoots during first spell
    [...] // code that shoots bullets - lasts for 108f
}[/code]

We want to cancel the attack when the call stack is ``sub121 → sub124``.

On Easy/Normal, the entire subroutine ``sub121`` lasts for ``472f`` before it loops. Out of the ``472f``, ``40f`` is spent on waiting. During other ``432f`` she is busy with attacking thus Merlin is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/472`` chance for Merlin to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Easy/Normal mode[/hl2]. 

On Hard/Lunatic, the entire subroutine ``sub121`` lasts for ``512f`` before it loops. Merlin is programmed to do nothing for ``40f`` on Hard/Lunatic, probably for balancing reasons. Out of the ``512f``, ``80f`` is spent on waiting. During other ``432f`` she is busy with attacking thus Merlin is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/512`` chance for Merlin to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Hard/Lunatic mode[/hl2].

### Merlin's subroutines - non-spell 3
[hr_minor]

The functions used for Merlin's third non-spell are as follows:

[code]void sub83() { // Merlin non-spell 3
    [...]
    loop {
        sub84(1.7671459); // lasts for 16 + 64f 
+30: // lasts for 30f
        sub60(30, 1.2); // lasts for 0f
+30: // lasts for 30f
        sub84(-1.7671459); // lasts for 16 + 64f
+30: // lasts for 30f
        sub60(30, 1.2); // lasts for 0f
+100: // lasts for 100f
        sub84(-1.7671459); // lasts for 16 + 64f
        sub84(1.7671459); // lasts for 16 + 64f
+20: // lasts for 20f
        sub84(-1.7671459); // lasts for 16 + 64f
        sub84(1.7671459); // lasts for 16 + 64f
+50: // lasts for 50f
        sub60(30, 1.2); // lasts for 0f
    }
}[/code]

[code]void sub84(float FPAR_0) { //Merlin nonspell 3 attack
    sub2(4, 32); // particle effects - last for 16f
    [...] // stuff she shoots - lasts for 64 frames
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub83 → sub84 → sub2``.

The entire subroutine ``sub83`` lasts for ``740f`` before it loops. Out of the ``740f``, ``432f`` is spent on attacking. Right before she attacks, she calls for ``sub2``, which per loop lasts for ``96f``. 
So, [hl2]there is a ``96/740`` chance for Merlin to exit the third non-spell[/hl2] with the call stack ``sub83 → sub84 → sub2``. 

### Merlin's subroutines - spell 2
[hr_minor]

The relevant functions used for the second spell used by Merlin are as follows:

[code]void sub138() { // Merlin spell 2
    [...]
    loop {
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(64.0, 160.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f
        sub139(64.0, 188.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f 
        sub139(64.0, 216.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f
        sub139(64.0, 244.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f 
        sub139(64.0, 272.0, F0, -0.09817477); // lasts for 0f
+100: // lasts for 100f 
        sub60(60, 1.5); // lasts for 0f
+60: // lasts for 60f 
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(352.0, 320.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 292.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 264.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 236.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 208.0, F0, -2.3561945); // lasts for 0f
+100: // lasts for 100f
        sub60(60, 1.5); // lasts for 0f
+60: // lasts for 60f
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(32.0, 48.0, F0, 1.5707964); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 76.0, F0, 1.3744467); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 104.0, F0, 0.5890486); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 132.0, F0, 0.3926991); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 160.0, F0, 0.0); // lasts for 0f
+20: // lasts for 20f
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(352.0, 48.0, F0, 1.5707964); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 76.0, F0, 1.7671459); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 104.0, F0, 2.552544); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 132.0, F0, 2.7488935); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 160.0, F0, 3.1415927); // lasts for 0f
+100: // lasts for 100f
        sub60(100, 1.5); // lasts for 0f
+100: // lasts for 100f
        sub2(4, 32);  // lasts for 16f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub138 → sub2``.

The entire subroutine ``sub138`` lasts for ``868f`` before it loops. Out of the ``868f``, ``80f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``80/868`` chance for Merlin to exit the third non-spell[/hl2] with the call stack ``sub138 → sub2``.

### Merlin's full call stack
[hr_minor]

During a full fight in which the Merlin glitch is triggered, Merlin's full call stack looks as follows:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → sub81 → sub2 → sub121 → sub124 → sub83 → sub84 → sub2 → sub138 → sub2 → sub142 → sub143 → [hl2]sub2[/hl2][/box]

Below I describe what each subroutine does in order:

1. ``sub71`` - Merlin is spawned
2. ``sub72`` - Merlin faces Sakuya in the first part of the boss fight
3. ``sub73`` - Waiting room
4. ``sub76`` - Merlin's 1st non-spell
5. ``sub80`` - Merlin's 2nd non-spell
6. ``sub81`` - Merlin's 2nd non-spell attack
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Merlin's 1st spell-card attack
10. ``sub83`` - Merlin's 3rd non-spell
11. ``sub84`` - Merlin's 3rd non-spell attack
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub138`` - Merlin's 2nd spell-card
14. ``sub2`` - Particle effects spawned during the 2nd spell-card
15. ``sub142`` - Prismrivers' 3rd spell-card
16. ``sub143`` - Prismrivers' 4th spell-card
17. ``sub2`` - Particle effects spawned at the start of the 4th spell-card by Merlin. This always happens.

[hl2]The Merlin glitch takes place when the last subroutine ``sub2`` in the full call stack is returned.[/hl2]

This has a very small probability of taking place. In essence, the following requirements must be met:
1. The player has to play as [hl2]Sakuya[/hl2].
2. The player has to [hl2]target Merlin[/hl2] during the 1st spell-card.
3. [hl2]On Easy/Normal, the probability of triggering this glitch is ``1/787``. On Hard/Lunatic, the probability of triggering this glitch is ``1/854``.[/hl2]

The probabilities were calculated as follows:
For Easy/Normal mode, the probability of getting the call stack ``sub71 → sub72 → [...] → sub143 → sub2`` is as follows:
[code]P(E/N sub71 → sub72 → [...] → sub143 → sub2)
= P(sub80 → sub81 → sub2) * P(E/N sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
= 80/690 * 432/472 * 96/740 * 80/868
= 13824 / 10895353
≈ 0.127%
≈ 1/787[/code]

For Lunatic/Hard mode, the probability of getting the call stack ``sub71 → sub72 → [...] → sub143 → sub2`` is as follows:

[code]P(L/H sub71 → sub72 → [...] → sub143 → sub2)
= P(sub80 → sub81 → sub2) * P(L/H sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
= 80/690 * 432/512 * 96/740 * 80/868
= 216 / 184667
≈ 0.117%
≈ 1/854[/code]

If you ever want to replicate the Merlin glitch yourself, remember that on average on Easy/Normal it would take [hl2]787 attempts[/hl2], and on Hard/Lunatic it would take [hl2]854 attempts[/hl2].


## [why]
[hr_minor]

During the Merlin glitch, Merlin's call stack looks as follows:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → sub81 → sub2 → sub121 → sub124 → sub83 → sub84 → sub2 → sub138 → sub2 → sub142 → sub143 → [hl2]sub2[/hl2][/box]

However, [hl2]the stack has a limit[/hl2] that is reached in the Merlin glitch.

### What is the stack?
[hr_minor]

A stack can be taken quite literally. Suppose you have a stack of papers (an organised pile, one on top of another). You can put another paper on top of the original stack (push) or take one of the top (pop). However, you never push/pop from the bottom or middle, as the stack would "collapse". A stack is useful if you are working on a task A and get interrupted by task B. You put A on the stack and start to work on B. When you're done with B, you check the stack to see what the previous task was. If C interrupts B, you put B on the stack, and start work on C.

In the context of Merlin, take for example the call stack ``sub80 → sub81 → sub2``. We first start off with the call stack ``sub80``. It then calls for ``sub81``, making the new call stack ``sub80 → sub81``. This once again calls for ``sub2``, which means the new call stack is ``sub80 → sub81 → sub2``. Once Merlin is done with spawning the particles in subroutine ``sub2``, then ``sub2`` is removed (popped) from the stack, and the call stack is now ``sub80 → sub81``. Merlin proceeds to execute the rest of ``sub81``. Once Merlin is done with ``sub81``, this subroutine ``sub81`` is popped from the stack and the call stack is now ``sub80``.

The following image describes what was written above:

[img=bugs/th07/0_stack1.png, hratio=2, other= ]


### The stack limit
[hr_minor]

However, there is a limit as to how large a stack can be. If the call stack is too large, then this can cause serious issues.
The context stack is an array of 16 slots. However, [hl2]ZUN made it such that only the first 15 slots of the stack work[/hl2]. The 16th slot acts as a mere buffer.

[img=bugs/th07/0_stack2.png, hratio=2, other= ]

### Stack overflow
[hr_minor]

Take the call stack again, alongside what each subroutine does:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → sub81 → sub2 → sub121 → sub124 → sub83 → sub84 → sub2 → sub138 → sub2 → sub142 → sub143 → [hl2]sub2[/hl2][/box]

1. ``sub71`` - Merlin is spawned
2. ``sub72`` - Merlin faces Sakuya in the first part of the boss fight
3. ``sub73`` - Waiting room
4. ``sub76`` - Merlin's 1st non-spell
5. ``sub80`` - Merlin's 2nd non-spell
6. ``sub81`` - Merlin's 2nd non-spell attack
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Merlin's 1st spell-card attack
10. ``sub83`` - Merlin's 3rd non-spell
11. ``sub84`` - Merlin's 3rd non-spell attack
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub138`` - Merlin's 2nd spell-card
14. ``sub2`` - Particle effects spawned during the 2nd spell-card
15. ``sub142`` - Prismrivers' 3rd spell-card
16. ``sub143`` - Prismrivers' 4th spell-card
17. ``sub2`` - Particle effects spawned at the start of the 4th spell-card by Merlin. This always happens.

The first 15 slots (``sub71, [...], sub142``) are pushed to the stack. The 16th slot (``sub143``) is a mere buffer - it is not pushed to the stack.
[hl2]Since ``sub143`` is not pushed to the stack, it means that any subroutines following ``sub143`` return to the 15th slot[/hl2] once those subroutines [hl2]return[/hl2]. In this case, the glitch happens once the last ``sub2`` returns. [hl2]This causes Merlin to return to ``sub142``, which is the Prismrivers' 3rd spell-card[/hl2].

[img=bugs/th07/0_stack3.png, hratio=2, other= ]

### Stack overflow on other bosses?
[hr_minor]

[hl2]The Prismriver sisters' boss-fight is implemented differently than how other bosses are implemented[/hl2]. In the case of the Prismriver sisters, they are [hl2]controlled by an invisible boss manager[/hl2]. This is different from other bosses in PCB. In this case, [hl2]the stack of the invisible boss manager gets reset[/hl2] whenever a life/timer callback is triggered.

### Lyrica/Lunasa bug?
[hr_minor]

But can this bug also happen with Lyrica/Lunasa ?
We take into consideration the call stacks of Lyrica and Lunasa.

The call stack, alongside the explanation of each subroutine of [hl2]Lyrica[/hl2] are as follows:

[box=1000] sub88 → sub89 → sub90 → sub95 → sub2 → sub98 → sub2 → sub121 → sub124 → sub103 → sub2 → sub145 → sub146/sub147/sub148/sub149 → sub150 → sub152 → sub52[/box]

1. ``sub88`` - Lyrica is spawned
2. ``sub89`` - Lyrica faces Marisa in the first part of the boss fight
3. ``sub90`` - Waiting room
4. ``sub95`` - Lyrica's 1st non-spell
5. ``sub2`` - Particle effects spawned during the 1st non-spell
6. ``sub98`` - Lyrica's 2nd non-spell
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Lyrica's 1st spell-card attack
10. ``sub103`` - Lyrica's 3rd non-spell
11. ``sub2`` - Particle effects spawned during the 3rd non-spell
12. ``sub145`` - Lyrica's 2nd spell-card
13. ``sub146/sub147/sub148/sub149`` - Lyrica's 2nd spell-card attack
14. ``sub150`` - Prismrivers' 3rd spell-card
15. ``sub152`` - Prismrivers' 4th spell-card
16. ``sub52`` - Boss dies

Lyrica is 1 call away from triggering the glitch, [hl2]so it is not possible to trigger the glitch on Lyrica[/hl2].

The call stack, alongside the explanation of each subroutine of [hl2]Lunasa[/hl2] are as follows:

[box=1000] sub53 → sub54 → sub55 → sub58 → sub59 → sub3 → sub64 → sub2 → sub121 → sub124 → sub68 → sub2 → sub127/sub128 → sub132/sub133 → sub135 → sub52[/box]

1. ``sub53`` - Lunasa is spawned
2. ``sub54`` - Lunasa faces Reimu in the first part of the boss fight
3. ``sub55``  - Waiting room
4. ``sub58`` - Lunasa's 1st non-spell
5. ``sub59`` - Lunasa's 1st non-spell attack
6. ``sub3`` - Particle effects spawned during the 1st non-spell attack
7. ``sub64`` - Lunasa's 2nd non-spell
8. ``sub2`` - Particle effects spawned during the 2nd non-spell
9. ``sub121`` - Prismrivers' 1st spell-card
10. ``sub124`` - Lunasa's 1st spell-card attack
11. ``sub68`` - Lunasa's 3rd non-spell
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub127/sub128`` - Lunasa's 2nd spell-card
14. ``sub132/sub133`` - Prismrivers' 3rd spell-card
15. ``sub135`` - Prismrivers' 4th spell-card
16. ``sub52`` - Boss dies

Lunasa is 1 call away from triggering the glitch, [hl2]so it is not possible to trigger the glitch on Lunasa[/hl2].

It is not possible to trigger the glitch on Lyrica or Lunasa, as those sisters are both one subroutine away from being able to trigger the glitch.

### Conclusion
[hr_minor]

[box=1000] In summary, the Merlin glitch is triggered through [hl2]precisely-timed kills on various patterns[/hl2] as Sakuya. There is roughly a [hl2]1 in 800 chance[/hl2] to get the Merlin glitch. This has to do with how the game handles the [hl2]call stack[/hl2]. The issue is caused because of [hl2]stack overflow[/hl2]. This causes Merlin to [hl2]return to the 3rd spell-card[/hl2] instead of to the 4th spell-card.[/box]

[hr_major]
## [links]
[hr_minor]
### [rpy]
[hr_minor]

+ [replay=6QslRdYpws]
+ [replay=PLv0zArCHT]
+ [replay=26nmhATHmN]
+ [replay=vSEJqDuDmA]

### [vid]
[hr_minor]

+ [cite=5JhFz2rmrG]
+ [cite=HRlIq8klSl]
+ [cite=i1O1kChzeC]
+ [cite=EWQEGVhayi]
+ [cite=ENDSVfmrh8]
