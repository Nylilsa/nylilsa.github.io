[title=PCB: Merlin, Lyrica & Lunasa Glitch]  
# Merlin, Lyrica & Lunasa Glitch
  
[hr_major]  
## [specs]  
[hr_minor]

* **Versions**: [unknown]1.00[/unknown] - [unknown]1.00a[/unknown] - [yes]1.00b[/yes]
* **Difficulty**: [yes]Easy[/yes] - [yes]Normal[/yes] - [yes]Hard[/yes] - [yes]Lunatic[/yes] - [no]Extra[/no] - [no]Phantasm[/no]
* **Mode**: [yes]Main game[/yes] - [yes]Practice mode[/yes]
* **Shottype**: [yes]ReimuA[/yes] - [yes]ReimuB[/yes] - [yes]MarisaA[/yes] - [yes]MarisaB[/yes] - [yes]SakuyaA[/yes] - [yes]SakuyaB[/yes]

<ol class='toc'>
Table of contents
        <li>[jumpto=#/bugs/th07/0#whathappens][what][/jumpto]</li>
        <li>[jumpto=#/bugs/th07/0#howithappens][how][/jumpto]
                <ol>
                        <li>[jumpto=#/bugs/th07/0#merlinssetup]Merlin's set-up[/jumpto]
                                <ol>
                                        <li>[jumpto=#/bugs/th07/0#merlinssubroutinesnonspell2]Merlin's subroutines - non-spell 2[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#merlinssubroutinesspell1]Merlin's subroutines - spell 1[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#merlinssubroutinesnonspell3]Merlin's subroutines - non-spell 3[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#merlinssubroutinesspell2]Merlin's subroutines - spell 2[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#merlinsfullcallstackfinalspellcardglitch]Merlin's full call stack - Final spell-card glitch[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#merlinscallstackpostbossglitch]Merlin's call stack - Post-boss glitch[/jumpto]</li>
                                </ol>
                        </li>
                        <li>[jumpto=#/bugs/th07/0#lyricassetup]Lyrica's set-up[/jumpto]
                                <ol>
                                        <li>[jumpto=#/bugs/th07/0#lyricassubroutinesnonspell1]Lyrica's subroutines - non-spell 1[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lyricassubroutinesnonspell2]Lyrica's subroutines - non-spell 2[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lyricassubroutinesspell1]Lyrica's subroutines - spell 1[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lyricassubroutinesnonspell3]Lyrica's subroutines - non-spell 3[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lyricassubroutinesspell2]Lyrica's subroutines - spell 2[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lyricasfullcallstackpostbossglitch]Lyrica's full call stack - Post-boss glitch[/jumpto]</li>
                                </ol>
                        </li>
                        <li>[jumpto=#/bugs/th07/0#lunasassetup]Lunasa's set-up[/jumpto]
                                <ol>
                                        <li>[jumpto=#/bugs/th07/0#lunasassubroutinesnonspell1]Lunasa's subroutines - non-spell 1[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lunasassubroutinesnonspell2]Lunasa's subroutines - non-spell 2[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lunasassubroutinesspell1]Lunasa's subroutines - spell 1[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lunasassubroutinesnonspell3]Lunasa's subroutines - non-spell 3[/jumpto]</li>
                                        <li>[jumpto=#/bugs/th07/0#lunasasfullcallstackpostbossglitch]Lunasa's full call stack - Post-boss glitch[/jumpto]</li>
                                </ol>
                        </li>
                </ol>
        </li> 
        <li>[jumpto=#/bugs/th07/0#whyithappens][why][/jumpto]
                <ol>
                        <li>[jumpto=#/bugs/th07/0#whatisthestack]What is the stack?[/jumpto]</li>
                        <li>[jumpto=#/bugs/th07/0#thestacklimit]The stack limit[/jumpto]</li>
                        <li>[jumpto=#/bugs/th07/0#stackoverflow]Stack overflow[/jumpto]</li>
                        <li>[jumpto=#/bugs/th07/0#stackoverflowonotherbosses]Stack overflow on other bosses?[/jumpto]</li>
                        <li>[jumpto=#/bugs/th07/0#conclusion]Conclusion[/jumpto]</li>
                </ol>
        </li>
        <li>[jumpto=#/bugs/th07/0#links][links][/jumpto]</li>
        <li>[jumpto=#/bugs/th07/0#replays][rpy][/jumpto]</li>
        <li>[jumpto=#/bugs/th07/0#videos][vid][/jumpto]</li>
</ol>




## [what]
[hr_minor]

Merlin behaves weirdly during and after the final spell-card.

[img=bugs/th07/0_merlin.png, hratio=2, other= ] [br]

There have been a number of reports in which Merlin bugged out. During this, there are various things Merlin does that do not make much sense.
Once, she kept moving around in circles, even after her final spell-card had happened.
Another time, she still attacked even though the fight has already ended.
Other times, she doesn't despawn after the final spell-card.

Replays are compatible with this bug.
This glitch is extraordinarily rare. [hl2]All current replays/videos[/hl2] related to the Merlin glitch that were uploaded before this page was published can be found in the [jumpto=#/bugs/th07/0#links]Links[/jumpto] section of this page.

[img=bugs/th07/0_lyrica_lunasa.png, hratio=2, other= ] [br]

Though, [hl2]as of 2021-08-30, it has been found out that a Lyrica & Lunasa glitch exists[/hl2].

The Lyrica & Lunasa glitch has had [hl2]no prior reports[/hl2]. However, Lyrica & Lunasa can only glitch out [hl2]after the final spell-card[/hl2], and not during. Similarly, replays are compatible with this bug.

## [how]
[hr_minor]

The details to do this glitch are quite specific. The set-up is similar across the Prismriver sisters, but each glitch is done differently. The code provided in this page was decompiled using [a=https://github.com/ExpHP/truth/releases/]truth[/a] v0.5.0.

### Merlin's set-up
[hr_custom=#FF9EE0]

[hl2]All the following criteria must be met[/hl2] for the [hl2]final spell-card Merlin glitch[/hl2], which is where Merlin uses her attack from her penultimate spell-card during her final spell-card..

1. Play as [hl2]Sakuya[/hl2]. This ensures you face Merlin during the first half of the fight.
2. End Merlin's 2nd non-spell during [hl2]a specific time frame[/hl2].
3. End the 1st spell during [hl2]a specific time frame[/hl2]. The time frame is quite large.
4. Target Merlin during the 1st spell.
5. End Merlin's 3rd non-spell during [hl2]a specific time frame[/hl2].
6. End Merlin's solo spell during [hl2]a very specific time frame[/hl2].

[hl2]All the following criteria must be met[/hl2] for the [hl2]post-boss Merlin glitch[/hl2], which is where Merlin still hangs around after the fight has ended.

1. Play as [hl2]Sakuya[/hl2]. This ensures you face Merlin during the first half of the fight.
2. Target Merlin during the 1st spell.

On top of this, exactly [hl2]three out of four[/hl2] following criteria must be met.
+ End Merlin's 2nd non-spell during [hl2]a specific time frame[/hl2].
+ End the 1st spell during [hl2]a specific time frame[/hl2]. The time frame is quite large.
+ End Merlin's 3rd non-spell during [hl2]a specific time frame[/hl2].
+ End Merlin's solo spell during [hl2]a very specific time frame[/hl2].

What the [hl2]specific time frame[/hl2] is is explained below alongside the probability of success per attack.

#### Merlin's subroutines - non-spell 2
[hr_minor]

A subroutine is a set of instructions designed to perform a frequently used operation within a program. Merlin frequently uses subroutines to spawn particle effects and to shoot bullets. In the following sections I denote the subroutines that are involved with the precisely-timed kills. In this section, I denote the subroutines for the 2nd non-spell.

For non-spell 2, the subroutines are as follows:
[code]void sub80() { // Merlin's 2nd non-spell
    [...]
    loop {
        sub81(1.7671459); // sub81 is the stuff Merlin shoots
+30: // 130
        sub60(30, 0.8); // sub60 makes Merlin move randomly - irrelevant
+30: // 160
        sub81(-1.7671459);
+30: // 190
        sub60(30, 0.8);
+100: // 290
        sub81(-1.7671459);
        sub81(1.7671459);
        sub81(-1.7671459);
+50: // 340
        sub60(30, 1.2);
+50: // 390
    }
}[/code]

[code]void sub81(float FPAR_0) { // what Merlin shoots during non-spell 2
    sub2(4, 32); // particle effects right before she shoots bullets
    [...] // stuff she shoots - lasts for 64 frames
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

So this might be a bit confusing, but I will explain what is going on during the 2nd non-spell.
Firstly, the subroutine ``sub80`` is called. This is Merlin's 2nd non-spell. Now, ``sub80`` can also call for other functions, such as ``sub60`` and ``sub81``. In this case, we want to look at ``sub81``, which is the one responsible for shooting the bullets. ``sub81`` happens to call for ``sub2``, which is responsible for these little particle effects she calls for before attacking. ``sub2`` lasts for exactly 16 frames.
So assuming we start the fight from the 2nd non-spell ``sub80``, Merlin's [hl2]call stack[/hl2] *can* look as follows: ``sub80 → sub81 → sub2``.
I put the word *can* in italics because the call stack can also be different. For example, it can look like this ``sub80 → sub81`` or even this ``sub80``! But note: it cannot be ``sub80 → sub60`` because ``sub60`` is executed instantly.
But wait, how exactly does this work? 
In essence, [hl2]every subroutine lasts for a certain amount of frames[/hl2]. Let's take a look at the code for ``sub80`` again:

[code]void sub80() { // Merlin's 2nd non-spell
    [...]
    loop {
        sub81(1.7671459); // lasts for 16 + 64f
+30: // lasts for 30f
        sub60(30, 0.8); // lasts for 0f
+30: // lasts for 30f
        sub81(-1.7671459);// lasts for 16 + 64f
+30: // lasts for 30f
        sub60(30, 0.8); // lasts for 0f
+100: // lasts for 100f
        sub81(-1.7671459); // lasts for 16 + 64f
        sub81(1.7671459); // lasts for 16 + 64f
        sub81(-1.7671459); // lasts for 16 + 64f
+50: // lasts for 50f
        sub60(30, 1.2); // lasts for 0f
+50: // lasts for 50f
    }
}[/code]
Basically, when the game says ``+50:``, it means that Merlin [hl2]is waiting for 50 frames long[/hl2]. During this time, if we were to end the 2nd non-spell, the call stack would look as follows: ``sub80``.
Secondly, suppose I were to end the 2nd non-spell [hl2]while Merlin is shooting her bullets[/hl2]. She is calling for ``sub81``, but in this case she is not calling for ``sub2``.  Because of this, the call stack would look as follows: ``sub80 → sub81``. 
Thirdly, suppose I were to end the 2nd non-spell [hl2]right before Merlin shoots her bullets[/hl2], so while the particle effects are spawning. She calls for ``sub81``, which calls for ``sub2``. The call stack would look as follows: ``sub80 → sub81 → sub2``. 

Now, [hl2]it's possible to calculate the chance to get the call stack ``sub80 → sub81 → sub2``[/hl2] assuming the probability of the time at which the pattern was killed is [hl2]uniformly distributed[/hl2] (i.e. the chances of killing Merlin during the 386th frame is the same as killing her on the 1024th frame). [hl2]This doesn't reflect real chances[/hl2] due to the fact players would want to speedkill Merlin and this may get consistent kills, but this is the least we could work with.

The entire subroutine ``sub80`` lasts for ``690f`` before it loops. Out of the ``690f``, ``260f`` is spent on waiting. During the other ``430f`` she is busy with attacking. Out of the ``430f``, there are ``80f`` where she is busy with calling for ``sub2``. 
So, [hl2]there is a ``80/690`` chance for Merlin to exit the 2nd non-spell[/hl2] with the call stack ``sub80 → sub81 → sub2``. 

#### Merlin's subroutines - spell 1
[hr_minor]

Similarly, we can calculate the probabilities for Merlin's other subroutines. The functions used for spell 1 are as follows:

[code]void sub121() { // First spell 
    [...]
    loop {
+40: // lasts for 40f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -4.712389); // lasts for 108f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -6.2831855); // lasts for 108f
        {"HL"}:  wait(40); // lasts for 40f only on Hard/Lunatic mode.
    }
}[/code]

[code]void sub124(float FPAR_0, float FPAR_1) { // stuff Merlin shoots during first spell
    [...] // code that shoots bullets - lasts for 108f
}[/code]

We want to cancel the attack when the call stack is ``sub121 → sub124``.

On Easy/Normal, the entire subroutine ``sub121`` lasts for ``472f`` before it loops. Out of the ``472f``, ``40f`` is spent on waiting. During the other ``432f`` she is busy with attacking thus Merlin is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/472`` chance for Merlin to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Easy/Normal mode[/hl2]. 

On Hard/Lunatic, the entire subroutine ``sub121`` lasts for ``512f`` before it loops. Merlin is programmed to do nothing for ``40f`` on Hard/Lunatic, probably for balancing reasons. Out of the ``512f``, ``80f`` is spent on waiting. During the other ``432f`` she is busy with attacking thus Merlin is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/512`` chance for Merlin to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Hard/Lunatic mode[/hl2].

#### Merlin's subroutines - non-spell 3
[hr_minor]

The functions used for Merlin's third non-spell are as follows:

[code]void sub83() { // Merlin's 3rd non-spell
    [...]
    loop {
        sub84(1.7671459); // lasts for 16 + 64f 
+30: // lasts for 30f
        sub60(30, 1.2); // lasts for 0f
+30: // lasts for 30f
        sub84(-1.7671459); // lasts for 16 + 64f
+30: // lasts for 30f
        sub60(30, 1.2); // lasts for 0f
+100: // lasts for 100f
        sub84(-1.7671459); // lasts for 16 + 64f
        sub84(1.7671459); // lasts for 16 + 64f
+20: // lasts for 20f
        sub84(-1.7671459); // lasts for 16 + 64f
        sub84(1.7671459); // lasts for 16 + 64f
+50: // lasts for 50f
        sub60(30, 1.2); // lasts for 0f
    }
}[/code]

[code]void sub84(float FPAR_0) { // Merlin's third non-spell attack
    sub2(4, 32); // particle effects - last for 16f
    [...] // stuff she shoots - lasts for 64 frames
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub83 → sub84 → sub2``.

The entire subroutine ``sub83`` lasts for ``740f`` before it loops. Out of the ``740f``, ``432f`` is spent on attacking. Right before she attacks, she calls for ``sub2``, which per loop lasts for ``96f``. 
So, [hl2]there is a ``96/740`` chance for Merlin to exit the third non-spell[/hl2] with the call stack ``sub83 → sub84 → sub2``. 

#### Merlin's subroutines - spell 2
[hr_minor]

The relevant functions used for the second spell used by Merlin are as follows:

[code]void sub138() { // Merlin spell 2
    [...]
    loop {
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(64.0, 160.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f
        sub139(64.0, 188.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f 
        sub139(64.0, 216.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f
        sub139(64.0, 244.0, F0, -0.09817477); // lasts for 0f
+8: // lasts for 8f 
        sub139(64.0, 272.0, F0, -0.09817477); // lasts for 0f
+100: // lasts for 100f 
        sub60(60, 1.5); // lasts for 0f
+60: // lasts for 60f 
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(352.0, 320.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 292.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 264.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 236.0, F0, -2.3561945); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 208.0, F0, -2.3561945); // lasts for 0f
+100: // lasts for 100f
        sub60(60, 1.5); // lasts for 0f
+60: // lasts for 60f
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(32.0, 48.0, F0, 1.5707964); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 76.0, F0, 1.3744467); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 104.0, F0, 0.5890486); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 132.0, F0, 0.3926991); // lasts for 0f
+8: // lasts for 8f 
        sub139(32.0, 160.0, F0, 0.0); // lasts for 0f
+20: // lasts for 20f
        sub2(4, 32); // lasts for 16f
+30: // lasts for 30f
        sub139(352.0, 48.0, F0, 1.5707964); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 76.0, F0, 1.7671459); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 104.0, F0, 2.552544); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 132.0, F0, 2.7488935); // lasts for 0f
+8: // lasts for 8f 
        sub139(352.0, 160.0, F0, 3.1415927); // lasts for 0f
+100: // lasts for 100f
        sub60(100, 1.5); // lasts for 0f
+100: // lasts for 100f
        sub2(4, 32);  // lasts for 16f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub138 → sub2``.

The entire subroutine ``sub138`` lasts for ``868f`` before it loops. Out of the ``868f``, ``80f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``80/868`` chance for Merlin to exit the third non-spell[/hl2] with the call stack ``sub138 → sub2``.

#### Merlin's full call stack - Final spell-card glitch
[hr_minor]

During a full fight in which the [hl2]final spell-card Merlin glitch[/hl2] is triggered, Merlin's full call stack looks as follows:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → sub81 → sub2 → sub121 → sub124 → sub83 → sub84 → sub2 → sub138 → sub2 → sub142 → sub143 → [hl2]sub2[/hl2][/box]

Below I describe what each subroutine does in order:

1. ``sub71`` - Merlin is spawned
2. ``sub72`` - Merlin faces Sakuya in the first part of the boss fight
3. ``sub73`` - Waiting room
4. ``sub76`` - Merlin's 1st non-spell
5. ``sub80`` - Merlin's 2nd non-spell
6. ``sub81`` - Merlin's 2nd non-spell attack
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Merlin's 1st spell-card attack
10. ``sub83`` - Merlin's 3rd non-spell
11. ``sub84`` - Merlin's 3rd non-spell attack
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub138`` - Merlin's 2nd spell-card
14. ``sub2`` - Particle effects spawned during the 2nd spell-card
15. ``sub142`` - Prismrivers' 3rd spell-card
16. ``sub143`` - Prismrivers' 4th spell-card
17. ``sub2`` - Particle effects spawned at the start of the 4th spell-card by Merlin. This always happens.

The [hl2]final spell-card Merlin glitch[/hl2] takes place when [hl2]the last subroutine ``sub2`` in the full call stack is returned.[/hl2]

This has a very small probability of taking place. In essence, the following requirements must be met:
1. The player has to play as [hl2]Sakuya[/hl2].
2. The player has to [hl2]target Merlin[/hl2] during the 1st spell-card.
3. [hl2]On Easy/Normal, the probability of triggering this glitch is ``1/787``. On Hard/Lunatic, the probability of triggering this glitch is ``1/854``.[/hl2]

The probabilities were calculated as follows:
For Easy/Normal mode, the probability of getting the call stack ``sub71 → sub72 → [...] → sub143 → sub2`` is as follows:
[code]P(E/N sub71 → sub72 → [...] → sub143 → sub2)
= P(sub80 → sub81 → sub2) * P(E/N sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
= 80/690 * 432/472 * 96/740 * 80/868
= 13824 / 10895353
≈ 0.127%
≈ 1/787[/code]

For Lunatic/Hard mode, the probability of getting the call stack ``sub71 → sub72 → [...] → sub143 → sub2`` is as follows:

[code]P(L/H sub71 → sub72 → [...] → sub143 → sub2)
= P(sub80 → sub81 → sub2) * P(L/H sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
= 80/690 * 432/512 * 96/740 * 80/868
= 216 / 184667
≈ 0.117%
≈ 1/854[/code]

This means on average for a random player to replicate the [hl2]final spell-card Merlin glitch[/hl2], on Easy/Normal it would take them [hl2]787 attempts[/hl2], and on Hard/Lunatic it would take them [hl2]854 attempts[/hl2].

#### Merlin's call stack - Post-boss glitch
[hr_minor]

During a full fight in which the [hl2]post-boss Merlin glitch[/hl2] is triggered, Merlin's full call stack looks as follows:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → [hl2]sub81[/hl2] → sub2 → sub121 → [hl2]sub124[/hl2] → sub83 → sub84 → [hl2]sub2[/hl2] → sub138 → [hl2]sub2[/hl2] → sub142 → sub143 → sub52[/box]

For the post-midboss Merlin glitch to happen, exactly three out of four conditions must be met:
+ ``sub80 → sub81 → sub2`` (done on 2nd non-spell)
+ ``sub121 → sub124`` (done on 1st spell)
+ ``sub83 → sub84 → sub2`` (done on 3rd non-spell)
+ ``sub138 → sub2`` (done on 2nd spell)

If less than three of the conditions are met, then the glitch does not happen. If four conditions are met, then Merlin does her final spell-card glitch.

Below I describe what each subroutine does in order:

1. ``sub71`` - Merlin is spawned
2. ``sub72`` - Merlin faces Sakuya in the first part of the boss fight
3. ``sub73`` - Waiting room
4. ``sub76`` - Merlin's 1st non-spell
5. ``sub80`` - Merlin's 2nd non-spell
6. ``sub81`` - Merlin's 2nd non-spell attack
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Merlin's 1st spell-card attack
10. ``sub83`` - Merlin's 3rd non-spell
11. ``sub84`` - Merlin's 3rd non-spell attack
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub138`` - Merlin's 2nd spell-card
14. ``sub2`` - Particle effects spawned during the 2nd spell-card
15. ``sub142`` - Prismrivers' 3rd spell-card
16. ``sub143`` - Prismrivers' 4th spell-card
17. ``sub52`` - Boss dies

The [hl2]post-boss Merlin glitch[/hl2] takes place when [hl2]the last subroutine ``sub52`` in the full call stack is returned ?[/hl2]

This has a very small probability of taking place. In essence, the following requirements must be met:
1. The player has to play as [hl2]Sakuya[/hl2].
2. The player has to [hl2]target Merlin[/hl2] during the 1st spell-card.
3. [hl2]On Easy/Normal, the probability of triggering this glitch is ``1/32``. On Hard/Lunatic, the probability of triggering this glitch is ``1/35``.[/hl2]

The probabilities were calculated as follows:
For Easy/Normal mode, the probability of getting the call stack ``sub71 → sub72 → [...] → sub143 → sub52`` with 3 out of 4 subs being true is as follows:
[code]P((E/N sub71 → sub72 → [...] → sub143 → sub52) with 3/4 subs true)
= P(sub80 → sub81 → sub2) * P(E/N sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 ⇏ sub2)
+ P(sub80 → sub81 → sub2) * P(E/N sub121 → sub124) * P(sub83 → sub84 ⇏ sub2) * P(sub138 → sub2)
+ P(sub80 → sub81 → sub2) * P(E/N sub121 ⇏ sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
+ P(sub80 → sub81 ⇏ sub2) * P(E/N sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
= 80/690 * 432/472 * 96/740 * 788/868 + 80/690 * 432/472 * 384/740 * 80/868 + 80/690 * 40/472 * 96/740 * 80/868 + 320/690 * 432/472 * 96/740 * 80/868
= 1240192 / 54476765
≈ 2.277%
≈ 1/44[/code]

For Lunatic/Hard mode, the probability of getting the call stack ``sub71 → sub72 → [...] → sub143 → sub52`` with 3 out of 4 subs being true is as follows:

[code]P((L/H sub71 → sub72 → [...] → sub143 → sub52) with 3/4 subs true)
= P(sub80 → sub81 → sub2) * P(H/L sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 ⇏ sub2)
+ P(sub80 → sub81 → sub2) * P(H/L sub121 → sub124) * P(sub83 → sub84 ⇏ sub2) * P(sub138 → sub2)
+ P(sub80 → sub81 → sub2) * P(H/L sub121 ⇏ sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
+ P(sub80 → sub81 ⇏ sub2) * P(H/L sub121 → sub124) * P(sub83 → sub84 → sub2) * P(sub138 → sub2)
= 80/690 * 432/512 * 96/740 * 788/868 + 80/690 * 432/512 * 384/740 * 80/868 + 80/690 * 40/472 * 96/740 * 80/868 + 320/690 * 432/512 * 96/740 * 80/868
= 1143802 / 54476765
≈ 2.100%
≈ 1/48[/code]

This means on average for a random player to replicate the [hl2]post-boss Merlin glitch[/hl2], on Easy/Normal it would take them [hl2]44 attempts[/hl2], and on Hard/Lunatic it would take them [hl2]48 attempts[/hl2].

### Lyrica's set-up
[hr_custom=#FE1D15]

[hl2]All the following criteria must be met[/hl2] for the Lyrica glitch.

1. Play as [hl2]Marisa[/hl2]. This ensures you face Lyrica during the first half of the fight.
2. End Lyrica's 1st non-spell during [hl2]a specific time frame[/hl2].
3. End Lyrica's 2nd non-spell during [hl2]a specific time frame[/hl2].
4. End the 1st spell during [hl2]a specific time frame[/hl2]. The time frame is quite large.
5. Target Lyrica during the 1st spell.
6. End Lyrica's 3rd non-spell during [hl2]a specific time frame[/hl2].
7. End Lyrica's solo spell during [hl2]a specific time frame[/hl2]. The time frame is quite large.

What the [hl2]specific time frame[/hl2] is is explained below alongside the probability of success per attack.

#### Lyrica's subroutines - non-spell 1
[hr_minor]

The functions used for Lyrica's first non-spell are as follows:

[code]void sub95() { // Lyrica's 1st non-spell
    [...]
    loop {
        sub2(4, 32); // particle effects - last for 16f
+30: // lasts for 30f
        [...] // stuff she shoots - lasts for 120f
        [...] // stuff she shoots - lasts for 120f
+100: // lasts for 100f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub95 → sub2``.

The entire subroutine ``sub95`` lasts for ``386f`` before it loops. Out of the ``386f``, ``16f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``16/386`` chance for Lyrica to exit the first non-spell[/hl2] with the call stack ``sub95 → sub2``.

#### Lyrica's subroutines - non-spell 2
[hr_minor]

The functions used for Lyrica's second non-spell are as follows:

[code]void sub98() { // Lyrica's 2nd non-spell
    [...]
    loop {
        sub2(4, 32); // lasts for 16f
        sub99(2); // lasts for 0f
+60: // lasts for 60f
        sub100(6); // lasts for 0f
        sub60(60, 1.3); // lasts for 0f
+60: // lasts for 60f
        sub99(2); // lasts for 0f
+30: // lasts for 30f
        sub100(6); // lasts for 0f
+60: // lasts for 60f
        sub60(60, 1.3); // lasts for 0f
+60: // lasts for 60f
        sub99(2); // lasts for 0f
+16: // lasts for 16f
        sub99(2); // lasts for 0f
+16: // lasts for 16f
        sub100(6); // lasts for 0f
+16: // lasts for 16f
        sub99(2); // lasts for 0f
+16: // lasts for 16f
        sub99(2); // lasts for 0f
+16: // lasts for 16f
        sub100(6); // lasts for 0f
+60: // lasts for 60f
        sub60(60, 1.3); // lasts for 0f
+60: // lasts for 60f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub98 → sub2``.

The entire subroutine ``sub98`` lasts for ``486f`` before it loops. Out of the ``486f``, ``16f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``16/486`` chance for Lyrica to exit the second non-spell[/hl2] with the call stack ``sub98 → sub2``.

#### Lyrica's subroutines - spell 1
[hr_minor]

The functions used for spell 1 are as follows:

[code]void sub121() { // First spell 
    [...]
    loop {
+40: // lasts for 40f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -4.712389); // lasts for 108f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -6.2831855); // lasts for 108f
        {"HL"}:  wait(40); // lasts for 40f only on Hard/Lunatic mode.
    }
}[/code]

[code]void sub124(float FPAR_0, float FPAR_1) { // stuff Lyrica shoots during first spell
    [...] // code that shoots bullets - lasts for 108f
}[/code]

We want to cancel the attack when the call stack is ``sub121 → sub124``.

On Easy/Normal, the entire subroutine ``sub121`` lasts for ``472f`` before it loops. Out of the ``472f``, ``40f`` is spent on waiting. During the other ``432f`` she is busy with attacking thus Lyrica is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/472`` chance for Lyrica to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Easy/Normal mode[/hl2]. 

On Hard/Lunatic, the entire subroutine ``sub121`` lasts for ``512f`` before it loops. Lyrica is programmed to do nothing for ``40f`` on Hard/Lunatic, probably for balancing reasons. Out of the ``512f``, ``80f`` is spent on waiting. During the other ``432f`` she is busy with attacking thus Lyrica is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/512`` chance for Lyrica to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Hard/Lunatic mode[/hl2].

#### Lyrica's subroutines - non-spell 3
[hr_minor]

The functions used for Lyrica's third non-spell are as follows:

[code]void sub103() { // Lyrica's 3rd non-spell
    [...]
    loop {
        sub2(4, 32); // lasts for 16f
        sub104(2); // lasts for 0f
+120: // lasts for 120f
        sub105(6); // lasts for 0f
        sub60(60, 0.6); // lasts for 0f
+60: // lasts for 60f
        sub104(2); // lasts for 0f
+60: // lasts for 60f
        sub105(6); // lasts for 0f
+60: // lasts for 60f
        sub60(60, 0.6); // lasts for 0f
+60: // lasts for 60f
        sub104(2); // lasts for 0f
+60: // lasts for 60f
        sub104(2); // lasts for 0f
+60: // lasts for 60f
        sub104(2); // lasts for 0f
+60: // lasts for 60f
        sub105(6); // lasts for 0f
+60: // lasts for 60f
        sub60(60, 0.6); // lasts for 0f
+60: // lasts for 60f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 16f
   [...] // spawns particle effects
}[/code]

We want to cancel the attack when the call stack is ``sub103 → sub2``.

The entire subroutine ``sub103`` lasts for ``676f`` before it loops. Out of the ``676f``, ``16f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``16/676`` chance for Lyrica to exit the third non-spell[/hl2] with the call stack ``sub103 → sub2``.

#### Lyrica's subroutines - spell 2
[hr_minor]

[code]void sub145() { // Lyrica spell 2
    [...]
    loop {
        {"EN"}:  sub146(2, I0); // lasts for 90f
        {"HL"}:  sub149(13, I0); // lasts for 50f
        {"EN"}:  sub147(6, I0); // lasts for 90f
        {"HL"}:  sub148(2, I0); // lasts for 75f
        sub60(60, 1.0); // lasts for 0f
+60: // lasts for 60f
        {"EN"}:  sub146(2, I0); // lasts for 90f
        {"HL"}:  sub149(13, I0); // lasts for 50f
        {"EN"}:  sub147(6, I0); // lasts for 90f
        {"HL"}:  sub148(6, I0); // lasts for 75f 
        sub60(60, 1.3); // lasts for 0f
        [...]
+60: // lasts for 60f
    }
}[/code]

[code]void sub146(int IPAR_0, int IPAR_1) { // stuff Lyrica shoots during second spell on Easy/Normal
    [...] // code that shoots bullets - lasts for 90f
}[/code]

[code]void sub147(int IPAR_0, int IPAR_1) { // stuff Lyrica shoots during second spell on Easy/Normal
    [...] // code that shoots bullets - lasts for 90f
}[/code]

[code]void sub148(int IPAR_0, int IPAR_1) { // stuff Lyrica shoots during second spell on Hard/Lunatic
    [...] // code that shoots bullets - lasts for 75f
}[/code]

[code]void sub149(int IPAR_0, int IPAR_1) { // stuff Lyrica shoots during second spell on Hard/Lunatic
    [...] // code that shoots bullets - lasts for 50f
}[/code]

We want to cancel the attack when the call stack is ``sub145 → sub146/sub147/sub148/sub149``.

On Easy/Normal, the entire subroutine ``sub145`` lasts for ``480f`` before it loops. Out of the ``480f``, ``360f`` is spent on attacking where Lyrica is busy with calling for ``sub146`` or ``sub147``. 
So, [hl2]there is a ``360/480`` chance for Lyrica to exit the 2nd spell[/hl2] with the call stack ``sub145 → sub146/sub147`` [hl2]on Easy/Normal mode[/hl2]. 

On Hard/Lunatic, the entire subroutine ``sub145`` lasts for ``370f`` before it loops. Out of the ``370f``, ``250f`` is spent on attacking where Lyrica is busy with calling for ``sub148`` or ``sub149``. 
So, [hl2]there is a ``250/370`` chance for Lyrica to exit the 2nd spell[/hl2] with the call stack ``sub145 → sub148/sub149`` [hl2]on Hard/Lunatic mode[/hl2].

#### Lyrica's full call stack - Post-boss glitch
[hr_minor]

During a full fight in which the Lyrica glitch is triggered, Lyrica's full call stack looks as follows:

[box=1000] sub88 → sub89 → sub90 → sub95 → sub2 → sub98 → sub2 → sub121 → sub124 → sub103 → sub2 → sub145 → sub146/sub147/sub148/sub149 → sub150 → sub152 → [hl2]sub52[/hl2][/box]

1. ``sub88`` - Lyrica is spawned
2. ``sub89`` - Lyrica faces Marisa in the first part of the boss fight
3. ``sub90`` - Waiting room
4. ``sub95`` - Lyrica's 1st non-spell
5. ``sub2`` - Particle effects spawned during the 1st non-spell
6. ``sub98`` - Lyrica's 2nd non-spell
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Lyrica's 1st spell-card attack
10. ``sub103`` - Lyrica's 3rd non-spell
11. ``sub2`` - Particle effects spawned during the 3rd non-spell
12. ``sub145`` - Lyrica's 2nd spell-card
13. ``sub146/sub147/sub148/sub149`` - Lyrica's 2nd spell-card attack
14. ``sub150`` - Prismrivers' 3rd spell-card
15. ``sub152`` - Prismrivers' 4th spell-card
16. ``sub52`` - Boss dies

[hl2]The Lyrica glitch takes place when the last subroutine ``sub52`` in the full call stack is reached (?)[/hl2]

This has a very small probability of taking place. In essence, the following requirements must be met:
1. The player has to play as [hl2]Marisa[/hl2].
2. The player has to [hl2]target Lyrica[/hl2] during the 1st spell-card.
3. [hl2]On Easy/Normal, the probability of triggering this glitch is ``1/45103``. On Hard/Lunatic, the probability of triggering this glitch is ``1/54307``.[/hl2]

The probabilities were calculated as follows:
For Easy/Normal mode, the probability of getting the call stack ``sub88 → sub89 → [...] → sub152 → sub52`` is as follows:
[code]P(E/N sub88 → sub89 → [...] → sub152 → sub52)
= P(sub95 → sub2) * P(sub98 → sub2) * P(E/N sub121 → sub124) * P(sub103 → sub2) * P(sub145 → sub146/sub147)
= 16/386 * 16/486 * 432/472 * 16/676 * 360/480
= 128 / 5773209
≈ 0.00222%
≈ 1/45103[/code]

For Lunatic/Hard mode, the probability of getting the call stack ``sub88 → sub89 → [...] → sub152 → sub52`` is as follows:

[code]P(L/H sub88 → sub89 → [...] → sub152 → sub52)
= P(sub95 → sub2) * P(sub98 → sub2) * P(H/L sub121 → sub124) * P(sub103 → sub2) * P(sub145 → sub148/sub149)
= 16/386 * 16/486 * 432/512 * 16/676 * 250/370
= 200 / 10861461
≈ 0.00184%
≈ 1/54307[/code]

This means on average for a random player to replicate the Lyrica glitch, on Easy/Normal it would take them [hl2]54,523 attempts[/hl2], and on Hard/Lunatic it would take them [hl2]69,553 attempts[/hl2].


### Lunasa's set-up
[hr_custom=#F8FB89]

[hl2]All the following criteria must be met[/hl2] for the Lunasa glitch.

1. Play as [hl2]Reimu[/hl2]. This ensures you face Lunasa during the first half of the fight.
2. End Lunasa's 1st non-spell during [hl2]a specific time frame[/hl2].
3. End Lunasa's 2nd non-spell during [hl2]a specific time frame[/hl2].
4. End the 1st spell during [hl2]a specific time frame[/hl2]. The time frame is quite large.
5. Target Lunasa during the 1st spell.
6. End Lunasa's 3rd non-spell during [hl2]a specific time frame[/hl2].

What the [hl2]specific time frame[/hl2] is is explained below alongside the probability of success per attack.


#### Lunasa's subroutines - non-spell 1
[hr_minor]

The functions used for Lunasa's first non-spell are as follows:

[code]void sub58() { // Lunasa's 1st non-spell
    [...]
    loop {
        sub59(128.0, 1, 6, 4, 5); // lasts for 31 + 8f
+60: // lasts for 60f
        sub60(100, 0.8); // lasts for 0f
+100: // lasts for 100f
        sub59(-128.0, 0, 2, 4, 6); // lasts for 31 + 8f
+60: // lasts for 60f
        sub60(100, 0.8); // lasts for 0f
+100: // lasts for 100f
        sub59(128.0, 1, 6, 4, 6); // lasts for 31 + 8f
+60: // lasts for 60f
        sub60(100, 0.8); // lasts for 0f
+100: // lasts for 100f
        sub59(-128.0, 0, 2, 4, 7); // lasts for 31 + 8f
+60: // lasts for 60f
        [...]
+100: // lasts for 100f
        sub59(64.0, 1, 6, 4, 3); // lasts for 31 + 8f
+30: // lasts for 30f
        sub59(-64.0, 1, 6, 4, 3); // lasts for 31 + 8f
+60: // lasts for 60f
        sub59(112.0, 0, 2, 4, 4); // lasts for 31 + 8f
        sub59(-112.0, 0, 2, 4, 4); // lasts for 31 + 8f
+60: // lasts for 60f
        sub59(160.0, 3, 13, 4, 5); // lasts for 31 + 8f
        sub59(-160.0, 3, 13, 4, 5); // lasts for 31 + 8f
+300: // lasts for 300f
        sub60(100, 0.8); // lasts for 0f
+100: // lasts for 100f
    }
}[/code]

[code]void sub59(float FPAR_0, int IPAR_0, int IPAR_1, int IPAR_2, int IPAR_3) {
    [...]
+1: // lasts for 1f
    sub3(2, 16, FPAR_0, 0.0); // lasts for 8f
    [...]
+30: // lasts for 30f
    [...]
}[/code]

[code]void sub3(int IPAR_0, int IPAR_1, float FPAR_0, float FPAR_1) { // spawns particle effects - lasts for 8f
    [...] // spawns particle effects
}[/code]

In this case, the shown code of ``sub58`` has been modified such that it does not take up the entire screen.

We want to cancel the attack when the call stack is ``sub58 → sub59 → sub3``.

The entire subroutine ``sub58`` lasts for ``1580f`` before it loops. Out of the ``1580f``, ``390f`` is spent on attacking using ``sub59``. Out of the ``390f``, ``80f`` is spent on spawning animation particles from ``sub3``.
So, [hl2]there is a ``80/1580`` chance for Lunasa to exit the first non-spell[/hl2] with the call stack ``sub58 → sub59 → sub3``.

#### Lunasa's subroutines - non-spell 2
[hr_minor]

The relevant functions used for Lunasa's second non-spell are as follows:

[code]void sub64() { // Lunasa's 2nd non-spell
    [...]
    loop {
        sub65(128, 16, 0.049087387, 0.0, 6, 3.0); // lasts for 0f
+60: // lasts for 60f
        sub65(128, 16, -0.049087387, 0.0, 2, 3.0); // lasts for 0f
+60: // lasts for 60f
        sub60(100, 0.8); // lasts for 0f
+100: // lasts for 100f
        sub2(2, 16); // lasts for 8f
+30: // lasts for 30f
        sub65(96, 16, 0.06544985, -1.5707964, 4, 3.0); // lasts for 0f
+30: // lasts for 30f
        sub65(96, 16, -0.06544985, 1.5707964, 3, 3.0); // lasts for 0f
+30: // lasts for 30f
        sub65(96, 16, 0.06544985, -1.5707964, 4, 3.0); // lasts for 0f
+30: // lasts for 30f
        sub65(96, 16, -0.06544985, 1.5707964, 3, 3.0); // lasts for 0f
+100: // lasts for 100f
        sub60(100, 0.8); // lasts for 0f
+50: // lasts for 50f
        sub2(2, 16); // lasts for 8f
+30: // lasts for 30f
        sub65(80, 8, 0.07853982, 3.1415927, 6, 4.6); // lasts for 0f
+30: // lasts for 30f
        sub65(80, 8, -0.07853982, -3.1415927, 6, 4.6); // lasts for 0f
+30: // lasts for 30f
        sub65(80, 8, 0.07853982, 1.5707964, 6, 4.6); // lasts for 0f
+30: // lasts for 30f
        sub65(80, 8, -0.07853982, -1.5707964, 6, 4.6); // lasts for 0f
+60: // lasts for 60f
        [...]
        sub65(60, 6, 0.10471976, 0.0, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub65(60, 6, -0.10471976, 0.0, 2, 2.5); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub65(60, 6, 0.10471976, 3.1415927, 2, 3.0); // lasts for 0f
+10: // lasts for 10f
        {"N"}:  sub65(60, 6, -0.10471976, 3.1415927, 2, 3.5); // lasts for 0f
        {"N"}:  sub65(60, 6, -0.10471976, 3.1415927, 2, 4.5); // lasts for 0f
        {"L"}:  sub65(60, 6, -0.10471976, 3.1415927, 2, 5.5); // lasts for 0f
        [...]
+120: // lasts for 120f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 8f
   [...] // spawns particle effects
}[/code]

Note: [hl2]A lot of redundant lines have been removed[/hl2] from the ``sub64`` code block on this page. This is done such that the code block does not take up the entire screen.

We want to cancel the attack when the call stack is ``sub64 → sub2``.

The entire subroutine ``sub64`` lasts for ``836f`` before it loops. Out of the ``836f``, ``16f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``16/836`` chance for Lunasa to exit the second non-spell[/hl2] with the call stack ``sub64 → sub2``.

#### Lunasa's subroutines - spell 1
[hr_minor]

The functions used for spell 1 are as follows:

[code]void sub121() { // First spell 
    [...]
    loop {
+40: // lasts for 40f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -4.712389); // lasts for 108f
        sub124(0.0, 4.712389); // lasts for 108f
        sub124(3.1415927, -6.2831855); // lasts for 108f
        {"HL"}:  wait(40); // lasts for 40f only on Hard/Lunatic mode.
    }
}[/code]

[code]void sub124(float FPAR_0, float FPAR_1) { // stuff Lunasa shoots during first spell
    [...] // code that shoots bullets - lasts for 108f
}[/code]

We want to cancel the attack when the call stack is ``sub121 → sub124``.

On Easy/Normal, the entire subroutine ``sub121`` lasts for ``472f`` before it loops. Out of the ``472f``, ``40f`` is spent on waiting. During the other ``432f`` she is busy with attacking thus Lunasa is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/472`` chance for Lunasa to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Easy/Normal mode[/hl2]. 

On Hard/Lunatic, the entire subroutine ``sub121`` lasts for ``512f`` before it loops. Lunasa is programmed to do nothing for ``40f`` on Hard/Lunatic, probably for balancing reasons. Out of the ``512f``, ``80f`` is spent on waiting. During the other ``432f`` she is busy with attacking thus Lunasa is busy with calling for ``sub124``. 
So, [hl2]there is a ``432/512`` chance for Lunasa to exit the 1st spell[/hl2] with the call stack ``sub121 → sub124`` [hl2]on Hard/Lunatic mode[/hl2].

#### Lunasa's subroutines - non-spell 3
[hr_minor]

The functions used for Lunasa's third non-spell are as follows:

[code]void sub68() { // Lunasa's 3rd non-spell
    [...]
    loop {
        sub2(2, 16); // lasts for 8f
        sub66(64, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(64, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub60(60, 0.8); // lasts for 0f
+60: // lasts for 60f
        sub2(2, 16); // lasts for 8f
        sub66(64, 8, 0.06544985, -1.5707964, 2, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, -0.06544985, 1.5707964, 2, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, 0.06544985, -1.5707964, 2, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, -0.06544985, 1.5707964, 2, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, 0.06544985, -1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(64, 8, -0.06544985, 1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, 0.06544985, -1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, -0.06544985, 1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, 0.06544985, -1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.06544985, 1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, 0.06544985, -1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub60(60, 0.8); // lasts for 0f
+60: // lasts for 16f
        sub2(2, 16); // lasts for 8f
        sub66(64, 8, 0.07853982, 3.1415927, 6, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, -0.07853982, 3.1415927, 6, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, 0.07853982, 3.1415927, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(64, 8, 0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, -0.07853982, 3.1415927, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.07853982, 3.1415927, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.07853982, 0.0, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.07853982, 3.1415927, 6, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub60(60, 0.8); // lasts for 0f
+60: // lasts for 60f
        sub2(2, 16); // lasts for 8f
        sub66(64, 8, 0.049087387, -0.3926991, 2, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, -0.049087387, 0.3926991, 2, 2.0); // lasts for 0f
+30: // lasts for 30f
        sub66(64, 8, 0.049087387, -0.7853982, 2, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, -0.049087387, 0.7853982, 2, 2.0); // lasts for 0f
+20: // lasts for 20f
        sub66(64, 8, 0.049087387, -1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(64, 8, -0.049087387, 1.5707964, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, 0.049087387, -3.1415927, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        sub66(56, 8, -0.049087387, 3.1415927, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, 0.049087387, -3.1415927, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.049087387, 3.1415927, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, 0.049087387, -3.1415927, 2, 2.0); // lasts for 0f
+10: // lasts for 10f
        {"NHL"}:  sub66(56, 8, -0.049087387, 3.1415927, 2, 2.0); // lasts for 0f
        {"HL"}:  sub66(80, 8, 0.049087387, -0.7853982, 2, 3.0); // lasts for 0f
        {"L"}:  sub66(80, 8, -0.049087387, 0.7853982, 2, 4.0); // lasts for 0f
+60: // lasts for 60f
    }
}[/code]

[code]void sub2(int IPAR_0, int IPAR_1) { // spawns particle effects - lasts for 8f
   [...] // spawns particle effects
}[/code]

Note: [hl2]A lot of redundant lines have been removed[/hl2] from the ``sub68`` code block on this page. This is done such that the code block does not take up the entire screen.

We want to cancel the attack when the call stack is ``sub68 → sub2``.

The entire subroutine ``sub98`` lasts for ``920f`` before it loops. Out of the ``920f``, ``32f`` is spent on spawning the animation particles of ``sub2``.
So, [hl2]there is a ``32/952`` chance for Lunasa to exit the third non-spell[/hl2] with the call stack ``sub68 → sub2``.

#### Lunasa's full call stack - Post-boss glitch
[hr_minor]

During a full fight in which the Lunasa glitch is triggered, Lunasa's full call stack looks as follows:

[box=1000] sub53 → sub54 → sub55 → sub58 → sub59 → sub3 → sub64 → sub2 → sub121 → sub124 → sub68 → sub2 → sub127/sub128 → sub132/sub133 → sub135 → [hl2]sub52[/hl2][/box]

1. ``sub53`` - Lunasa is spawned
2. ``sub54`` - Lunasa faces Reimu in the first part of the boss fight
3. ``sub55``  - Waiting room
4. ``sub58`` - Lunasa's 1st non-spell
5. ``sub59`` - Lunasa's 1st non-spell attack
6. ``sub3`` - Particle effects spawned during the 1st non-spell attack
7. ``sub64`` - Lunasa's 2nd non-spell
8. ``sub2`` - Particle effects spawned during the 2nd non-spell
9. ``sub121`` - Prismrivers' 1st spell-card
10. ``sub124`` - Lunasa's 1st spell-card attack
11. ``sub68`` - Lunasa's 3rd non-spell
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub127/sub128`` - Lunasa's 2nd spell-card
14. ``sub132/sub133`` - Prismrivers' 3rd spell-card
15. ``sub135`` - Prismrivers' 4th spell-card
16. ``sub52`` - Boss dies

[hl2]The Lunasa glitch takes place when the last subroutine ``sub52`` in the full call stack is reached (?)[/hl2]

This has a very small probability of taking place. In essence, the following requirements must be met:
1. The player has to play as [hl2]Reimu[/hl2].
2. The player has to [hl2]target Lunasa[/hl2] during the 1st spell-card.
3. [hl2]On Easy/Normal, the probability of triggering this glitch is ``1/33543``. On Hard/Lunatic, the probability of triggering this glitch is ``1/36385``.[/hl2]

The probabilities were calculated as follows:
For Easy/Normal mode, the probability of getting the call stack ``sub53 → sub54 → [...] → sub152 → sub52`` is as follows:
[code]P(E/N sub53 → sub54 → [...] → sub152 → sub52)
= P(sub58 → sub59 → sub3) * P(sub64 → sub2) * P(E/N sub121 → sub124) * P(sub68 → sub2)
= 80/1580 * 16/836 * 432/472 * 32/952
= 3456 / 115923731
≈ 0.00298%
≈ 1/33543[/code]

For Lunatic/Hard mode, the probability of getting the call stack ``sub53 → sub54 → [...] → sub152 → sub52`` is as follows:

[code]P(L/H sub53 → sub54 → [...] → sub152 → sub52)
= P(sub58 → sub59 → sub3) * P(sub64 → sub2) * P(H/L sub121 → sub124) * P(sub68 → sub2)
= 80/1580 * 16/836 * 432/512 * 32/952
= 54 / 1964809
≈ 0.00275%
≈ 1/36385[/code]

This means on average for a random player to replicate the Lunasa glitch, on Easy/Normal it would take them [hl2]33,543 attempts[/hl2], and on Hard/Lunatic it would take them [hl2]36,385 attempts[/hl2]. 


## [why]
[hr_minor]

During the [hl2] final spell-card Merlin glitch[/hl2], Merlin's call stack looks as follows:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → sub81 → sub2 → sub121 → sub124 → sub83 → sub84 → sub2 → sub138 → sub2 → sub142 → sub143 → [hl2]sub2[/hl2][/box]

However, [hl2]the stack has a limit[/hl2] that is reached in the Merlin glitch.

### What is the stack?
[hr_minor]

[a=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)]The stack[/a] can be taken quite literally. Suppose you have a stack of papers (an organised pile, one on top of another). You can put another paper on top of the original stack (push) or take one of the top (pop). However, you never push/pop from the bottom or middle, as the stack would "collapse". A stack is useful if you are working on a task A and get interrupted by task B. You put A on the stack and start to work on B. When you're done with B, you check the stack to see what the previous task was. If C interrupts B, you put B on the stack, and start work on C.

In the context of Merlin, take for example the call stack ``sub80 → sub81 → sub2``. We first start off with the call stack ``sub80``. It then calls for ``sub81``, making the new call stack ``sub80 → sub81``. This once again calls for ``sub2``, which means the new call stack is ``sub80 → sub81 → sub2``. Once Merlin is done with spawning the particles in subroutine ``sub2``, then ``sub2`` is removed (popped) from the stack, and the call stack is now ``sub80 → sub81``. Merlin proceeds to execute the rest of ``sub81``. Once Merlin is done with ``sub81``, this subroutine ``sub81`` is popped from the stack and the call stack is now ``sub80``.

The following image describes what was written above:

[img=bugs/th07/0_stack1.png, hratio=2, other= ]


### The stack limit
[hr_minor]

However, there is a limit as to how large a stack can be. If the call stack is too large, then this can cause serious issues.
The context stack is an array of 16 slots. However, [hl2]ZUN made it such that only the first 15 slots of the stack work[/hl2]. The 16th slot acts as a mere buffer.

[img=bugs/th07/0_stack2.png, hratio=2, other= ]

### Stack overflow
[hr_minor]

Take the call stack of the [hl2]final spell-card Merlin glitch[/hl2] again, alongside what each subroutine does:

[box=1000] sub71 → sub72 → sub73 → sub76 → sub80 → sub81 → sub2 → sub121 → sub124 → sub83 → sub84 → sub2 → sub138 → sub2 → sub142 → sub143 → [hl2]sub2[/hl2][/box]

1. ``sub71`` - Merlin is spawned
2. ``sub72`` - Merlin faces Sakuya in the first part of the boss fight
3. ``sub73`` - Waiting room
4. ``sub76`` - Merlin's 1st non-spell
5. ``sub80`` - Merlin's 2nd non-spell
6. ``sub81`` - Merlin's 2nd non-spell attack
7. ``sub2`` - Particle effects spawned during the 2nd non-spell
8. ``sub121`` - Prismrivers' 1st spell-card
9. ``sub124`` - Merlin's 1st spell-card attack
10. ``sub83`` - Merlin's 3rd non-spell
11. ``sub84`` - Merlin's 3rd non-spell attack
12. ``sub2`` - Particle effects spawned during the 3rd non-spell
13. ``sub138`` - Merlin's 2nd spell-card
14. ``sub2`` - Particle effects spawned during the 2nd spell-card
15. ``sub142`` - Prismrivers' 3rd spell-card
16. ``sub143`` - Prismrivers' 4th spell-card
17. ``sub2`` - Particle effects spawned at the start of the 4th spell-card by Merlin. This always happens.

The first 15 slots (``sub71, [...], sub142``) are pushed to the stack. The 16th slot (``sub143``) is a mere buffer - it is not pushed to the stack.
[hl2]Since ``sub143`` is not pushed to the stack, it means that any subroutines following ``sub143`` return to the 15th slot[/hl2] once those subroutines [hl2]return[/hl2]. In this case, the glitch happens once the last ``sub2`` returns. [hl2]This causes Merlin to return to ``sub142``, which is the Prismrivers' 3rd spell-card[/hl2].

[img=bugs/th07/0_stack3.png, hratio=2, other= ]

### Stack overflow on other bosses?
[hr_minor]

[hl2]The Prismriver sisters' boss-fight is implemented differently than how other bosses are implemented[/hl2]. In the case of the Prismriver sisters, they are [hl2]controlled by an invisible boss manager[/hl2]. This is different from other bosses in PCB. In this case, [hl2]the stack of the invisible boss manager gets reset[/hl2] whenever a life/timer callback is triggered.

### Conclusion
[hr_minor]

[box=1000] The Merlin/Lyrica/Lunasa glitch is triggered through [hl2]precisely-timed kills on various patterns[/hl2] as Sakuya/Marisa/Reimu respectively. There is roughly a [hl2]1 in 800 chance[/hl2] to get the final spell-card Merlin glitch. For Merlin to glitch out after the final spell-card, there is roughly a lenient [hl2]1 in 32 chance.[/hl2] For Lunasa to glitch out, its probability is roughly a [hl2]1 in 35,000 chance[/hl2]. For Lyrica to glitch out, its probability is roughly a [hl2]1 in 50,000 chance[/hl2].  This has to do with how the game handles the [hl2]call stack[/hl2]. The issue is caused because of [hl2]stack overflow[/hl2]. This causes the sisters to [hl2]prematurely return to their previous attack[/hl2] instead of letting the fight flow normally.[/box]

[hr_major]
## [links]
[hr_minor]
### [rpy]
[hr_minor]

+ [replay=6QslRdYpws]
+ [replay=PLv0zArCHT]
+ [replay=26nmhATHmN]
+ [replay=vSEJqDuDmA]
+ [replay=g3TRR5bGdv]
+ [replay=0m17ZCJ0ef]

### [vid]
[hr_minor]

+ [cite=5JhFz2rmrG]
+ [cite=HRlIq8klSl]
+ [cite=i1O1kChzeC]
+ [cite=EWQEGVhayi]
+ [cite=ENDSVfmrh8]
+ [cite=Na19l8CMf4]
+ [cite=cLNCEmYPwZ]
